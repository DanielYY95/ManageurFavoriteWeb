/*
1. TypeError: Failed to execute 'addEventListener' on 'EventTarget': parameter 2 is not of type 'Object'.
    at /script.js:19:9
==> 잘,,,,

2. 클릭 시 hidden 클래스를 없애고 form이 나와야하는데,,,, 일단 문제는 form 설정을 제대로 하지 않았고,,,

3. 계속 Cannot read property 'preventDefault' of undefined 에러가 있는데,
function argument에 event 넣어주고, addEventListener에 있는 function에 ()를 적지 않았더니 에러가 해결되었다???

4. 새로운 문제. a 태그에 대한 토글을 설정했더니 그 아래 있는 것들도 토글이 되어버렸네....
function(){} 은 어떻게 작동하는지 이해하자!!! 
그리고 toggle을 사용하면 input, button 까지 적용되기 때문에 일단은 remove로 적용해놨다. 다른 대안은 없나... ===> 닫기 버튼을 따로 만든다???

5. 토글 활용: first_1.addEventListener("click", function(){
  first1_Form.classList.toggle('hidden');
===>> 그냥 function 토글 하나 만들고 onclick="toggle()" 이런식으로 해놓으면 된다. 

6. 클릭하면 input창이 열려있는 것과 localStorage에 null 값인 경우 열려있는 것이 서로 상충하네.... 그냥 null 조건을 없애버려야하나... 

====>>> 일단 이름과 url 모두 null인 아닌 경우에 설정하게 해놨다... 이걸 삭제했을 때 문제를 생각해보기도 해야겠다. 

7. 즉시 반영되야하지만 새로고침해야 반영되는 부분을 어떻게 고칠까???


8. TypeError: Cannot read property 'addEventListener' of null
HTML이 모두 로드되기전에 자바스크립트 영역에서 HTML을 참조하는데 addEventListener에서 HTML태그를 참조하지 못해서 계속 에러가 발생했다.

첫번째 방법, script 영역(아래 코드에서 노랑부분)을 body 태그 아래에 위치시킵니다.

head 태그 내부에 script 영역(노랑부분)이 있죠.
<!DOCTYPE html> <html> <head> <script src="myscript.js"></script> </head> <body> <input type="button" id="hw" value="Hello world" /> </body> </html>
script 영역(노랑 부분)을 body 태그 아래로 이동시켜요!

<!DOCTYPE html> <html> <head> // body태그 아래로 이동 </head> <body> <input type="button" id="hw" value="Hello world" /> </body> <script src="myscript.js"></script> </html>
즉, script 영역을 페이지의 하단에 위치시켜서 HTML의 로드가 모두 완료된 후, script 영역을 부르는 거죠!
가장 일반적인 방법입니다.

두번째 방법, 문제가 되는 함수를 window.onload 함수 내부에 넣습니다.

window.onload = function(){} 함수는 웹브라우저의 모든 구성요소에 대한 로드가 끝났을 때 브라우저에 의해서 호출되는 함수로,
해당 부분에 넣으면 HTML을 모두 로드한 뒤에 함수를 호출합니다. 

head태그 내부에 script 영역을 참조하는 부분이 있지만, window.onload 함수 내부에 문제가 되는 함수를 넣어줌으로써 해결됩니다.

<!DOCTYPE html> <html> <head> <script src="script2.js"></script> </head> <body> <input type="button" id="hw" value="Hello world" /> </body> </html>

window.onload = function(){ var hw = document.getElementById('hw'); hw.addEventListener('click', function(){ alert('Hello world'); }) }

9. function page(){
  location.href= first1_UrlInput.value;
location.href 같은 경우는 href 에 있는 링크를 기본 페이지로 설정하겠다는 의미로, page() 함수가 호출되는 즉시 href에 설정된 링크로 이동하게 될 것

10. 닫기 버튼
- onclick="first_1_Form.style.display= 'none'" 로 닫을 수는 있으나, 한번 닫히나 새로고침할 때까지 못 여네.....

+ 보이기 버튼
onclick="first_1_Form.style.display='block'" 으로도 가능!!

11. TypeError: Failed to execute 'appendChild' on 'Node': parameter 1 is not of type 'Node'. 에러

12. li와 a, form 태그를 분리하면 toggle을 사용할 수 있는 장점이 있지만 데이터가 날라가버리는 문제.... 또한, 설정된 이름을 누를때마다 form이 또 열리는...
 
13. 표시만 하고 데이터 지우기

const getNickName = localStorage.getItem("nickname");
const getUrl = localStorage.getItem("url");

if (getNickName != null && getUrl != null) {
  first1_Form.classList.add("hidden");
  first_1.innerText = getNickName;
  first_1.href = getUrl;
  firfir.onclick=""; 
  first_1.onclick=""; 
  deleteData(); // localStorage.removeItem("nickname"); localStorage.removeItem("url");
} 

로컬스토리지에 데이터가 있을경우 그 데이터를 표시하고 지우도록 deleteData()를 콜했기 때문

14. 화면에 바로 뿌려주는...
해당 스크립트의 실행 시점에 따라 달라지는 문제입니다.
저게 function 으로 이루어져있다면 해당 function을 호출만 하면 화면에 뿌릴 수 있겠지만
function이 아닌 load 상태에서 이뤄지는 스크립트라면
saveName, saveUrl보다 이전에 실행되게 되어서
saveName, saveUrl이후에는 실행되지 않게 됩니다.

해당 로직을 이용하시려면 function으로 감싸시고 load되는 script에서 한번 콜하시고(바로 화면 출력)
saveName, saveUrl 동작할 때 한번 콜하시면(계속 유지) 저장 후 로드까지 될꺼에요

16. function aa() {
  return false; /* a href를 작동하지 않게 하는 것 
} // 이런식으로 기본적인 이벤트를 작동하지않게 할 수 있다.
// onclick 에 작성 시  onclick="return aa();"  이렇게 작성해야한다.


17. id 부여
- 빈 array 배열을 만든다.
- 저장할 때,  string 형태로 저장한다.
- newData 와 같이 각 요소를 {name: --- , url:----, id:----} 꼴로 저장할 수 있도록 선언.
- newData 를 활용하여 저장하고 표출.


18. findindex 객체의 주소찾기(특히, 객체가 갖고있는 속성을 활용하여)
예시)
const arr = [
  {name : 'banana', price: 1000},
  {name : 'apple', price:1500},
  {name : 'orange', price: 2000}
];

function findApple(element)  {
  if(element.name === 'apple') return true;
}

document.writeln(arr.findIndex(findApple)); // 1

//배열에서 특정 항목이 몇번째 원소인지를 알고 싶을 때 사용한다.

const superheroes = ['아이언맨', '캡틴 아메리카', '토르', '닥터 스트레인지'];
const index = superheroes.indexOf('토르');
console.log(index); // 2
1
2
3
const superheroes = ['아이언맨', '캡틴 아메리카', '토르', '닥터 스트레인지'];
const index = superheroes.indexOf('토르');
console.log(index); // 2
배열 안에 있는 값들이 객체이거나 특정 조건을 확인해야하는 경우에는 findIndex를 사용한다.


19. filter

var arr2 = arr.filter(function (n) {
    return n % 5 == 0;
==> var arr2 = arr.filter((n)=>return n % 5 == 0);
// 5의 배수인 것만 포함한 배열로 탄생


20. 
TypeError: Cannot read property 'forEach' of null
    at /script.js:71:14
TypeError: Cannot read property 'push' of null
    at HTMLButtonElement.setWeb (/script.js:53:9)

forEach, push 쓰는 변수가 배열이 맞는지 콘솔 찍어서 확인

==>>> nList 를 콘솔했는데 null 인 경우도 있고, [] 경우도 있다. 뭐여...

21. 드래그 앤 드롭
draggable="true" ondrop="drop(event)"

});

*/

22. SyntaxError: Unexpected end of input
- 보통 {} 잘 안 되서 생기는 에러. 나의 경우는 */ 로 생기는 것 같은디??

23.  일단 function MAIN 안에 function 을 선언해도 MAIN만 실행하면 같이 실행되는 듯. 
 FORM.addEventListener is not a function 에러가 뜨는데, FORM이 배열이라 작동이 안 되는듯... 
 getElementsByClassName returns an HTMLCollection, not an element. 


 24. IIFE
 /*
function main(){
  const A = document.body.getElementsByTagName('a'); // 태그 이름으로 불러온다.
  const FORM = document.body.getElementsByTagName('form');
  const LI = document.body.getElementsByTagName('li');
    for (i = 0; i < A.length; i++) {
          function aa(idx){
            FORM[idx].submit = function bb(event){
              event.preventDefault();
              function setWeb(idx){
                  const newData= {nickname: NameInput.value, url: UrlInput.value, id:Date.now()};
                  NameInput.value = "";
    UrlInput.value = "";
                  nList.push(newData); // array에 저장
                  saveData();
                  paintData(newData, idx);
            }
          function createX(idx){
              const xButton = document.createElement('button');
              xButton.innerHTML = "❌";
              LI[idx].appendChild(xButton); 
              xButton.addEventListener("click", deleteData); 
        }
          function paintData(newdata, idx){
              FORM[idx].classList.add("hidden");
              A[idx].innerText = newData.nickname;
              A[idx].href = newData.url;
              FORM[idx].id = newData.id; 
              li[idx].onclick = ""; 
              A[idx].onclick = "";
            } 
          }
        }
      }(i);
}
main();
*/


// 피드백: 잘못 올려주셨거나 IIFE를 잘못 작성한 것 같습니다. 그리고 main 함수가 실행되면 setWeb과 creatX 함수는 선언만 되고 실행은 되지 않을것 같습니다. 선언과 실행은 다르니 참고하시길 바랍니다


25. form index 문제

// querySelectorAll 사용하여 form[i].addEventListener 정상으로 작동 합니다.
참고가 되면 좋겠네요

// 사소한 거긴 한데 일단 document.body.get... 쓰셨는데 가운데 body는 안 쓰셔도 됩니다. 
그리고 상수가 아닌 이상 대문자로 선언도 안 한답니다. 오류가 나는 건 아니고 그냥 그렇게 하기로 해놓은 규칙같은 겁니다. (A, LI, FORM 등) 
그리고 저 FORM console.log로 찍어서 값 확인해 보셨나요? FORM[0] 도 전부 콘솔로 로그 찍어서 값을 확인해보세요. 아니면 각 form에 다른 id를 주시고 각각 따로 getElement.. 나 qureyS.. 로 불러오는 방법도 있습니다.

26. input vs textarea 

input은 한 줄의 텍스트 입력 창
textarea 태그는 여러 줄의 텍스트를 입력하는 창을 만든다. 얘 form 가능하고, cols와 rows를 통해 너비와 줄의 개수를 설정해줘야한다. 그리고 wrap = "" 에서 "" 안에 들어갈 hard는 텍스트 줄바꿈, soft는 기본값이자 줄바꿈 되지 않는 것을 의미한다.


27. 키보드 엔터 막기
- document.querySelector("#Content").addEventListener("keydown",function(event){
  if (event.keyCode === 13) {
        event.preventDefault();
    }
});   => 이런식으로 하되, 범위 정해주는 건 머리를 좀 써야... document는 전체이니까, 해당되는 곳을 전체 블록으로 하고 거기에 id부여해서 설정. 

// 키 다운이 발생했을 때, 함수. 해당 event의 keycode가 13이라면 발생하는 기본 이벤트를 멈춰라. true 는 무슨 뜻이지?? true 이면 작동하라는 소리인가??? event는 어떤 사건이라고 생각하면 된다. 뒤에 true 가 없어도 작동하긴 하는데,,, ==> Option true 이면, Capturing 방식으로 이벤트가 전달되며, false 이며, Bubling 방식으로 이벤트가 전달된다. 기본값은 false이다.


//키보드 이벤트(Keyboard Event)는 사용자가 키를 누르거나 키를 놓을 때 발생합니다. 키를 누를 때는 keydown 타입 이벤트가 발생하고, 키를 놓을 때는 keyup 타입 이벤트가 발생합니다. 

28. float:right; // 오른쪽 정렬 
vertical-align; // 요소의 수직 정렬을 지정하는 속성이다.
